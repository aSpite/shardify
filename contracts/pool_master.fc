#include "imports/stdlib.fc";
#include "constants.fc";

global slice storage::admin_address;
global int storage::public_key;

() load_data() impure {
    slice ds = get_data().begin_parse();
    storage::admin_address = ds~load_msg_addr();
    storage::public_key = ds~load_uint(256);
}

() save_data() impure {
    set_data(begin_cell()
        .store_slice(storage::admin_address)
        .store_uint(storage::public_key, 256)
        .end_cell()
    );
}

() recv_internal(int my_balance, int msg_value, cell in_msg_full, slice in_msg_body) impure {
    if (in_msg_body.slice_empty?()) {
        return();
    }
    slice cs = in_msg_full.begin_parse();
    int flags = cs~load_uint(4);
    slice sender_address = cs~load_msg_addr();

    int op = in_msg_body~load_uint(32);
    int query_id = in_msg_body~load_uint(64);

    load_data();
    if(op == op::create_pool) {
        slice signature = in_msg_body~load_bits(512);
        cell payload = in_msg_body~load_ref();
        throw_unless(error::unauthorized, check_signature(cell_hash(payload), signature, storage::public_key));
        slice ps = payload.begin_parse();
        int price = ps~load_coins();
        ;; TODO: Handle creation fee
        throw_unless(error::insufficient_gas, msg_value >= (price + fee::pool_creation));
        cell init_data = begin_cell()
            .store_coins(0)
            .store_slice(my_address())
            .store_slice(ps)
            .end_cell();
        cell init_code = in_msg_body~load_ref();
        in_msg_body.end_parse();
        raw_reserve(price, 4);
        cell state_init = begin_cell()
            .store_uint(0, 2)
            .store_dict(init_code)
            .store_dict(init_data)
            .store_uint(0, 1)
            .end_cell();
        slice minter_address = begin_cell()
            .store_uint(4, 3)
            .store_uint(const::workchain, 8)
            .store_uint(cell_hash(state_init), 256)
            .end_cell()
            .begin_parse();
        send_raw_message(begin_cell()
            .store_uint(flag::bounceable, 6)
            .store_slice(minter_address)
            .store_coins(100000000) ;; 0.1 TON
            .store_uint(1, 1 + 4 + 4 + 64 + 32 + 1)
            .store_uint(1, 1)
            .store_ref(state_init)
            .store_uint(0, 1)
            .end_cell(), 1);

        send_raw_message(begin_cell()
            .store_uint(flag::non_bounceable, 6)
            .store_slice(sender_address)
            .store_coins(0)
            .store_uint(0, 1 + 4 + 4 + 64 + 32 + 1 + 1)
            .store_uint(op::excesses, 32)
            .store_uint(query_id, 64)
            .end_cell(), 128);
        return();
    }
}
